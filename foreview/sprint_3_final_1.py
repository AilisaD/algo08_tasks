# 50459252

"""
-- ПРИНЦИП РАБОТЫ --
Для решения задачи поиска за время O(log(n)) подходит бинарный поиск.
Т.е. каждый раз отрезок поиска должен уменьшаться вдвое.

По задаче, массив отсортирован, но со сдвигом.
Т.е. состоит из 2-х отсортированных частей: [4, 5, 6, 1, 2].

Функция search() реализует бинарный поиск на подобном массиве.

Сразу проверяем средний и крайние элементы отрезка и,
в случае нахождения искомого элемента, возвращаем индекс.

Если отрезок отсортирован (левый элемент меньше правого),
то рекурсивно вызываем search() по условиям обычного бинарного поиска.
Далее рекурсия пойдет только по ветке отсортированного массива.

Если массив "сломан", то условия рекурсивного вызова search()
идут не по среднему элементу, а по крайним,
которые в отсортированном массиве были бы в середине.


-- ДОКАЗАТЕЛЬСВО КОРРЕКТНОСТИ --
Если массив "сломан", то проверяем какой части
должен принадлежать элемент:
 - если элемент больше первого элемента отрезка,
 то он ищется в левой части отрезка
 (к примеру, 100):
        [19 21 100 101 | 1 4 5 7 12]
 кроме случая, когда он лежит дальше среднего элемента
 (к примеру, 106):
        [19 21 100 101 103 | 105 106 107 1 4 5].
 - если элемент меньше первого элемента,
 то он должен лежать в правой части отрезка:
        [19 21 100 101 | 1 4 5 7 12]
 кроме случая, когда он меньше среднего элемента
 (к примеру, 2):
        [19 21 1 2 3 | 4 5 6 7 8 9].


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Операция бинарного поиска выполняется за O(log(n)).


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Т.к. мы храним все элементы в массиве размером n,
то пространственная сложность будет O(n).
"""


def search(array: list, x: int, left: int, right: int):
    if right <= left:
        return -1

    mid = (left + right) // 2

    if array[mid] == x:
        return mid

    if x == array[left]:
        return left

    if x == array[right - 1]:
        return right - 1

    if array[left] < array[right-1]:
        if x < array[mid]:
            return search(array, x, left, mid)
        else:
            return search(array, x, mid + 1, right)

    if x > array[left]:
        if x > array[mid] > array[left]:
            return search(array, x, mid + 1, right)
        else:
            return search(array, x, left, mid)

    else:
        if x < array[mid] < array[right-1]:
            return search(array, x, left, mid)
        else:
            return search(array, x, mid + 1, right)


def main():
    with open('input.txt') as reader:
        next(reader)
        x = int(reader.readline())
        array = [int(a) for a in reader.readline().split()]
    idx = search(array, x, 0, len(array))
    with open('output.txt', 'w') as writer:
        writer.write(str(idx))


if __name__ == "__main__":
    main()
