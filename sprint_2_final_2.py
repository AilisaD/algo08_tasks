# 49779537

"""
Я решила задачу на основе стека (класс собственный, чтобы не импортировать лишнюю библиотеку), т.к. он лучше всего
подходит для решения выражений в польской нотации - необходимо иметь доступ только к вершине списка.

По алгоритму: при встрече знака какой-либо операции произвести ее вычисление с двумя предыдущими операндами.
Т.е. 3 2 + -> операция + над операндами 3 и 2 -> 5. Результат так же надо хранить для возможных дальнейших операций.

Идем по строке и записываем каждое число в стек. Если встречается операция, то извлекаем 2 числа из вершины стека
(они и являются последними операндами,
брать числа необходимо в порядке их занесения, поэтому сначала извлекается второй операнд, а затем первый).
Записываем результат вычислений в стек.
Результат по заданию необходимо округлять вниз, для этого вызвалась функйия floor из библиотеки math.

---- Доказательство корректности:
При использовании стека, сколько бы ни было операций, ответ - результат последней операции - на вершине стека.

7 2 + 10 [в обычной записи: (7+2)-10 = 9-10 = -1]

Заполняем стек 7 2
Выполняется + над 7 и 2 -> 9 -> заносим в стек
Заносим в стек 10
Выполняется операция - над 9 и 10 -> -1 -> заносим в стек
Вывод результата -> -1

Если же в конце подается не операция, а число, то ответом будет являться оно, что так же корректно сработает, т.к.
на вершине стека будет находиться уже оно.

---- Временная сложность.
Добавление элементов в стек занимает O(1). Извлечение так же за O(1). Поэтому временная сложность алгоритма зависит
только от длины строки, поданной на вход - O(n).



"""
from math import floor


class Stack:
    def __init__(self):
        self.items = []

    def push(self, value):
        self.items.append(value)

    def pop(self):
        if self.size == 0:
            return 'error'
        return self.items.pop()

    @property
    def size(self):
        return len(self.items)


def solve(st, op):
    operand_2 = st.pop()
    operand_1 = st.pop()
    return floor(float(eval(f'{operand_1}{op}{operand_2}')))


if __name__ == '__main__':
    stack = Stack()
    operand = ''
    with open('input.txt', 'r') as reader:
        byte = reader.read(1)
        while byte:
            if byte == ' ':
                if operand.replace(' ', '') in '+*/-':
                    operand = solve(stack, operand)
                stack.push(operand)
                operand = ''
            operand += byte
            byte = reader.read(1)
        operand = operand.replace('\n', '').replace(' ', '')
        if operand.replace('\n', '') in '+*/-':
            stack.push(solve(stack, operand))
        else:
            stack.push(operand)

    with open('output.txt', 'w') as writer:
        writer.write(f'{stack.pop()}')
